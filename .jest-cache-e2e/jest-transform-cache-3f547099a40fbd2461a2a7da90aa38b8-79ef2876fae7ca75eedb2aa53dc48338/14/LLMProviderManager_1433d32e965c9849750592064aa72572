1dd94c5d0c9ad096f43ec9f674a8b0ba
/**
 * LLM Provider Manager
 * 
 * Central manager for all LLM providers with failover capabilities,
 * provider selection logic, and health monitoring.
 */

const {
  BaseProvider,
  OpenAIProvider,
  AnthropicProvider
} = require('./providers');
const FailoverManager = require('./FailoverManager');
const PromptVersionManager = require('./PromptVersionManager');
const logger = require('../utils/logger');
class LLMProviderManager {
  constructor(config = {}) {
    this.config = {
      healthCheckInterval: 30000,
      // 30 seconds
      maxConsecutiveFailures: 3,
      providerTimeout: 30000,
      // 30 seconds
      ...config
    };
    this.providers = new Map();
    this.healthCheckInterval = null;
    this.isShuttingDown = false;

    // Initialize prompt version manager
    this.promptVersionManager = new PromptVersionManager(config.prompts || {});

    // Initialize enhanced failover manager
    this.failoverManager = new FailoverManager(config.failover || {});

    // Set up event listeners for failover events
    this.setupFailoverEventListeners();
    this.initializeProviders(config);

    // Initialize failover manager with providers
    this.failoverManager.initialize(this.providers);
    this.startHealthMonitoring();
  }

  /**
   * Set up event listeners for failover manager
   */
  setupFailoverEventListeners() {
    this.failoverManager.on('execution_success', data => {
      logger.debug('Provider execution succeeded', data);
    });
    this.failoverManager.on('provider_failure', data => {
      logger.warn('Provider execution failed', data);
      // Update local health tracking when provider fails
      this.handleProviderFailure(data.provider, new Error(data.error));
    });
    this.failoverManager.on('all_providers_failed', data => {
      logger.error('All providers failed', data);
    });
    this.failoverManager.on('circuit_breaker_opened', data => {
      logger.error('Circuit breaker opened for provider', data);
    });
    this.failoverManager.on('provider_recovered', data => {
      logger.info('Provider recovered from failure', data);
      // Reset local health tracking when provider recovers
      const health = this.providerHealth[data.provider];
      if (health) {
        health.consecutiveFailures = 0;
        health.isAvailable = true;
        health.lastFailure = null;
      }
    });
  }
  initializeProviders(config) {
    // Initialize OpenAI provider if configured
    if (config.openai?.apiKey) {
      try {
        const provider = new OpenAIProvider(config.openai);
        this.providers.set('openai', provider);
        // Also set as property for backward compatibility with tests
        this.providers.openai = provider;
        logger.info('OpenAI provider initialized');
      } catch (error) {
        logger.error('Failed to initialize OpenAI provider', {
          error: error.message
        });
      }
    }

    // Initialize Anthropic provider if configured
    if (config.anthropic?.apiKey) {
      try {
        const provider = new AnthropicProvider(config.anthropic);
        this.providers.set('anthropic', provider);
        // Also set as property for backward compatibility with tests
        this.providers.anthropic = provider;
        logger.info('Anthropic provider initialized');
      } catch (error) {
        logger.error('Failed to initialize Anthropic provider', {
          error: error.message
        });
      }
    }
    if (this.providers.size === 0) {
      throw new Error('No LLM providers configured. Please provide API keys for at least one provider.');
    }

    // Initialize provider health tracking for backward compatibility
    this.providerHealth = {};
    for (const [name, provider] of this.providers) {
      this.providerHealth[name] = {
        consecutiveFailures: 0,
        lastFailure: null,
        isAvailable: true
      };
    }
  }

  /**
   * Execute a completion request with automatic failover
   * @param {Object} request - Completion request
   * @returns {Promise<Object>} Completion result with metadata
   */
  async execute(request) {
    return this.executeWithFailover(request);
  }

  /**
   * Execute a completion request with automatic failover
   * @param {Object} request - Completion request
   * @returns {Promise<Object>} Completion result with metadata
   */
  async executeWithFailover(request) {
    if (this.isShuttingDown) {
      throw new Error('Provider manager is shutting down');
    }
    const {
      taskType = 'general',
      ...completionRequest
    } = request;
    logger.info('Executing completion request', {
      taskType,
      model: completionRequest.model,
      hasPrompt: !!completionRequest.prompt
    });
    try {
      const startTime = Date.now();

      // Use enhanced failover manager for execution
      const result = await this.failoverManager.executeWithFailover(completionRequest);
      const endTime = Date.now();

      // Enhance result with expected metadata
      const enhancedResult = {
        ...result,
        metadata: {
          ...result.metadata,
          totalDuration: endTime - startTime,
          executionTimestamp: endTime
        }
      };
      logger.info('Completion request executed successfully', {
        provider: result.provider,
        model: result.model,
        cost: result.cost?.total || 0,
        duration: endTime - startTime
      });
      return enhancedResult;
    } catch (error) {
      logger.error('All providers failed for completion request', {
        error: error.message,
        taskType
      });
      throw error;
    }
  }

  /**
   * Execute request with a specific provider
   * @param {Object} provider - Provider instance
   * @param {Object} request - Completion request
   * @returns {Promise<Object>} Completion result with metadata
   */
  async executeWithProvider(provider, request) {
    if (this.isShuttingDown) {
      throw new Error('Provider manager is shutting down');
    }
    try {
      const startTime = Date.now();
      const result = await provider.complete(request);
      const endTime = Date.now();

      // Add provider metadata
      const enhancedResult = {
        ...result,
        provider: provider.getName(),
        metadata: {
          ...result.metadata,
          totalDuration: endTime - startTime,
          executionTime: endTime - startTime,
          executionTimestamp: endTime,
          provider: provider.getName()
        }
      };

      // Record success in failover manager
      this.failoverManager.recordSuccess(provider.getName(), endTime - startTime, result.cost?.total || 0);
      return enhancedResult;
    } catch (error) {
      // Enhance error with provider context
      error.provider = provider.getName();
      error.duration = Date.now();
      error.message = `Provider error: ${error.message}`;

      // Record failure in failover manager
      this.failoverManager.recordFailure(provider.getName(), error);
      throw error;
    }
  }

  /**
   * Handle provider failure and update health tracking
   * @param {string} providerName - Name of the failed provider
   * @param {Error} error - The error that occurred
   */
  handleProviderFailure(providerName, error) {
    const health = this.providerHealth[providerName];
    if (!health) {
      logger.warn('Attempted to handle failure for unknown provider', {
        providerName
      });
      return;
    }
    health.consecutiveFailures++;
    health.lastFailure = new Date();

    // Mark provider as unavailable if too many failures
    if (health.consecutiveFailures >= this.config.maxConsecutiveFailures) {
      health.isAvailable = false;
      logger.warn('Provider marked as unavailable due to consecutive failures', {
        provider: providerName,
        consecutiveFailures: health.consecutiveFailures
      });
    }

    // Also record in failover manager
    this.failoverManager.recordFailure(providerName, error);
    logger.debug('Provider failure recorded', {
      provider: providerName,
      consecutiveFailures: health.consecutiveFailures,
      isAvailable: health.isAvailable,
      error: error.message
    });
  }

  /**
   * Get the best available provider for a given task
   * @param {string} taskType - Type of task (e.g., 'summarization', 'extraction')
   * @param {number} documentSize - Size of document in characters
   * @param {Array<string>} excludeProviders - Providers to exclude from selection
   * @returns {Object} Selected provider
   */
  async getProvider(taskType = 'general', documentSize = 0, excludeProviders = []) {
    const availableProviders = this.getAvailableProviders(excludeProviders);
    if (availableProviders.length === 0) {
      throw new Error('No available providers for task execution');
    }

    // Provider selection strategy based on task type and document size
    const selectedProvider = this.selectProviderByStrategy(availableProviders, taskType, documentSize);
    logger.info('Provider selected for task', {
      provider: selectedProvider.getName(),
      taskType,
      documentSize,
      availableProviders: availableProviders.map(p => p.getName())
    });
    return selectedProvider;
  }

  /**
   * Get list of available (healthy) providers
   * @param {Array<string>} excludeProviders - Providers to exclude
   * @returns {Array<Object>} Available provider instances
   */
  getAvailableProviders(excludeProviders = []) {
    return Array.from(this.providers.values()).filter(provider => {
      if (excludeProviders.includes(provider.getName())) return false;
      const health = this.providerHealth[provider.getName()];
      return health?.isAvailable && provider.isHealthy;
    });
  }

  /**
   * Select provider based on task requirements
   * @param {Array<Object>} providers - Available providers
   * @param {string} taskType - Task type
   * @param {number} documentSize - Document size
   * @returns {Object} Selected provider
   */
  selectProviderByStrategy(providers, taskType, documentSize) {
    // Strategy 1: For large documents, prefer providers with higher token limits
    if (documentSize > 50000) {
      const preferredOrder = ['anthropic', 'openai'];
      for (const providerName of preferredOrder) {
        const provider = providers.find(p => p.getName() === providerName);
        if (provider) return provider;
      }
    }

    // Strategy 2: For cost-sensitive tasks, prefer cheaper providers
    if (taskType === 'bulk_processing') {
      const preferredOrder = ['anthropic', 'openai']; // Anthropic Haiku is cheaper
      for (const providerName of preferredOrder) {
        const provider = providers.find(p => p.getName() === providerName);
        if (provider) return provider;
      }
    }

    // Strategy 3: For high-quality tasks, prefer premium models
    if (taskType === 'critical_analysis') {
      const preferredOrder = ['openai', 'anthropic']; // GPT-4 for critical tasks
      for (const providerName of preferredOrder) {
        const provider = providers.find(p => p.getName() === providerName);
        if (provider) return provider;
      }
    }

    // Default: Return provider with lowest error rate
    return providers.reduce((best, current) => {
      const bestHealth = this.providerHealth[best.getName()];
      const currentHealth = this.providerHealth[current.getName()];
      return currentHealth.consecutiveFailures < bestHealth.consecutiveFailures ? current : best;
    });
  }

  /**
   * Start periodic health monitoring
   */
  startHealthMonitoring() {
    // Skip health monitoring if interval is 0 (for testing)
    if (this.config.healthCheckInterval === 0) {
      logger.info('Health monitoring disabled (interval = 0)');
      return;
    }
    this.healthCheckInterval = setInterval(async () => {
      await this.performHealthChecks();
    }, this.config.healthCheckInterval);
    logger.info('Health monitoring started', {
      interval: this.config.healthCheckInterval
    });
  }

  /**
   * Perform health checks on all providers
   */
  async performHealthChecks() {
    const healthPromises = Array.from(this.providers.entries()).map(async ([name, provider]) => {
      try {
        const health = await provider.healthCheck();
        if (health.healthy) {
          // Reset availability if provider is healthy again
          this.providerHealth[name].isAvailable = true;
          this.providerHealth[name].consecutiveFailures = 0;
        }
        return {
          name,
          health
        };
      } catch (error) {
        logger.error('Health check failed', {
          provider: name,
          error: error.message
        });
        return {
          name,
          health: {
            healthy: false,
            error: error.message
          }
        };
      }
    });
    const results = await Promise.allSettled(healthPromises);
    logger.debug('Health check completed', {
      results: results.map(r => r.status === 'fulfilled' ? r.value : {
        error: r.reason
      })
    });
  }

  /**
   * Get system health and statistics
   * @returns {Object} Health and stats summary
   */
  getSystemHealth() {
    const providerStats = Array.from(this.providers.entries()).map(([name, provider]) => ({
      name,
      ...provider.getStats(),
      health: this.providerHealth[name]
    }));
    const totalRequests = providerStats.reduce((sum, p) => sum + p.requestCount, 0);
    const totalErrors = providerStats.reduce((sum, p) => sum + p.errorCount, 0);
    const availableProviders = providerStats.filter(p => p.health.isAvailable).length;

    // Get enhanced failover statistics
    const failoverStats = this.failoverManager.getFailoverStats();
    return {
      totalProviders: this.providers.size,
      availableProviders,
      totalRequests,
      totalErrors,
      errorRate: totalRequests > 0 ? totalErrors / totalRequests : 0,
      providers: providerStats,
      failover: failoverStats
    };
  }

  /**
   * Initialize prompt version manager
   */
  async initializePromptVersioning() {
    try {
      await this.promptVersionManager.initialize();
      logger.info('Prompt versioning system initialized');
    } catch (error) {
      logger.error('Failed to initialize prompt versioning', {
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Execute enrichment with versioned prompt
   * @param {string} promptId - ID of the prompt to use
   * @param {Object} variables - Variables to substitute in the prompt
   * @param {Object} options - Execution options
   * @returns {Promise<Object>} Enrichment result with prompt metadata
   */
  async executeWithPrompt(promptId, variables = {}, options = {}) {
    try {
      const {
        promptVersion = 'latest',
        provider = null,
        taskType = 'enrichment',
        ...executeOptions
      } = options;

      // Get the versioned prompt
      const prompt = await this.promptVersionManager.getPrompt(promptId, promptVersion);
      if (!prompt) {
        throw new Error(`Prompt not found: ${promptId} (version: ${promptVersion})`);
      }

      // Substitute variables in prompt content
      const processedContent = this.substitutePromptVariables(prompt.content, variables);

      // Execute with failover
      const result = await this.executeWithFailover({
        taskType,
        prompt: processedContent,
        ...executeOptions
      });

      // Add prompt metadata to result
      return {
        ...result,
        promptMetadata: {
          promptId,
          promptVersion: prompt.version,
          variables,
          promptHash: this.generatePromptHash(prompt),
          executionTimestamp: new Date().toISOString()
        }
      };
    } catch (error) {
      logger.error('Failed to execute with prompt', {
        promptId,
        promptVersion: options.promptVersion,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Substitute variables in prompt content
   * @param {string} content - Prompt content with variables
   * @param {Object} variables - Variables to substitute
   * @returns {string} Processed content
   */
  substitutePromptVariables(content, variables) {
    let processedContent = content;
    for (const [key, value] of Object.entries(variables)) {
      const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
      processedContent = processedContent.replace(regex, String(value));
    }

    // Check for unsubstituted variables
    const unsubstituted = processedContent.match(/\{\{\w+\}\}/g);
    if (unsubstituted) {
      logger.warn('Unsubstituted variables found in prompt', {
        variables: unsubstituted,
        promptContent: processedContent.substring(0, 100) + '...'
      });
    }
    return processedContent;
  }

  /**
   * Generate hash for prompt reproducibility
   * @param {Object} prompt - Prompt object
   * @returns {string} Hash string
   */
  generatePromptHash(prompt) {
    const crypto = require('crypto');
    const hashData = {
      id: prompt.id,
      version: prompt.version,
      content: prompt.content
    };
    return crypto.createHash('sha256').update(JSON.stringify(hashData)).digest('hex');
  }

  /**
   * Save or update a prompt
   * @param {string} promptId - Prompt identifier
   * @param {Object} promptData - Prompt content and metadata
   * @param {Object} options - Save options
   * @returns {Promise<Object>} Saved prompt
   */
  async savePrompt(promptId, promptData, options = {}) {
    try {
      return await this.promptVersionManager.savePrompt(promptId, promptData, options);
    } catch (error) {
      logger.error('Failed to save prompt', {
        promptId,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Get a prompt by ID and version
   * @param {string} promptId - Prompt identifier
   * @param {string} version - Prompt version (default: 'latest')
   * @returns {Promise<Object|null>} Prompt object or null
   */
  async getPrompt(promptId, version = 'latest') {
    try {
      return await this.promptVersionManager.getPrompt(promptId, version);
    } catch (error) {
      logger.error('Failed to get prompt', {
        promptId,
        version,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * List all available prompts
   * @returns {Array<string>} Array of prompt IDs
   */
  listPrompts() {
    return this.promptVersionManager.listPrompts();
  }

  /**
   * Get version history for a prompt
   * @param {string} promptId - Prompt identifier
   * @returns {Array<Object>} Version history
   */
  getPromptVersionHistory(promptId) {
    return this.promptVersionManager.getVersionHistory(promptId);
  }

  /**
   * Rollback prompt to a previous version
   * @param {string} promptId - Prompt identifier
   * @param {string} targetVersion - Target version to rollback to
   * @returns {Promise<Object>} Rollback result
   */
  async rollbackPrompt(promptId, targetVersion) {
    try {
      return await this.promptVersionManager.rollbackPrompt(promptId, targetVersion);
    } catch (error) {
      logger.error('Failed to rollback prompt', {
        promptId,
        targetVersion,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Get prompt versioning statistics
   * @returns {Object} Statistics
   */
  getPromptStatistics() {
    return this.promptVersionManager.getStatistics();
  }

  /**
   * Gracefully shutdown the provider manager
   */
  async shutdown() {
    this.isShuttingDown = true;
    logger.info('Shutting down LLM Provider Manager');

    // Stop health monitoring
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }

    // Shutdown failover manager
    await this.failoverManager.shutdown();

    // Shutdown prompt version manager
    await this.promptVersionManager.shutdown();

    // Shutdown all providers
    const shutdownPromises = Array.from(this.providers.values()).map(async provider => {
      try {
        if (typeof provider.shutdown === 'function') {
          await provider.shutdown();
        }
      } catch (error) {
        logger.error('Error shutting down provider', {
          provider: provider.getName(),
          error: error.message
        });
      }
    });
    await Promise.all(shutdownPromises);
    logger.info('LLM Provider Manager shutdown complete');
  }
}
module.exports = LLMProviderManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJCYXNlUHJvdmlkZXIiLCJPcGVuQUlQcm92aWRlciIsIkFudGhyb3BpY1Byb3ZpZGVyIiwicmVxdWlyZSIsIkZhaWxvdmVyTWFuYWdlciIsIlByb21wdFZlcnNpb25NYW5hZ2VyIiwibG9nZ2VyIiwiTExNUHJvdmlkZXJNYW5hZ2VyIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJoZWFsdGhDaGVja0ludGVydmFsIiwibWF4Q29uc2VjdXRpdmVGYWlsdXJlcyIsInByb3ZpZGVyVGltZW91dCIsInByb3ZpZGVycyIsIk1hcCIsImlzU2h1dHRpbmdEb3duIiwicHJvbXB0VmVyc2lvbk1hbmFnZXIiLCJwcm9tcHRzIiwiZmFpbG92ZXJNYW5hZ2VyIiwiZmFpbG92ZXIiLCJzZXR1cEZhaWxvdmVyRXZlbnRMaXN0ZW5lcnMiLCJpbml0aWFsaXplUHJvdmlkZXJzIiwiaW5pdGlhbGl6ZSIsInN0YXJ0SGVhbHRoTW9uaXRvcmluZyIsIm9uIiwiZGF0YSIsImRlYnVnIiwid2FybiIsImhhbmRsZVByb3ZpZGVyRmFpbHVyZSIsInByb3ZpZGVyIiwiRXJyb3IiLCJlcnJvciIsImluZm8iLCJoZWFsdGgiLCJwcm92aWRlckhlYWx0aCIsImNvbnNlY3V0aXZlRmFpbHVyZXMiLCJpc0F2YWlsYWJsZSIsImxhc3RGYWlsdXJlIiwib3BlbmFpIiwiYXBpS2V5Iiwic2V0IiwibWVzc2FnZSIsImFudGhyb3BpYyIsInNpemUiLCJuYW1lIiwiZXhlY3V0ZSIsInJlcXVlc3QiLCJleGVjdXRlV2l0aEZhaWxvdmVyIiwidGFza1R5cGUiLCJjb21wbGV0aW9uUmVxdWVzdCIsIm1vZGVsIiwiaGFzUHJvbXB0IiwicHJvbXB0Iiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJlc3VsdCIsImVuZFRpbWUiLCJlbmhhbmNlZFJlc3VsdCIsIm1ldGFkYXRhIiwidG90YWxEdXJhdGlvbiIsImV4ZWN1dGlvblRpbWVzdGFtcCIsImNvc3QiLCJ0b3RhbCIsImR1cmF0aW9uIiwiZXhlY3V0ZVdpdGhQcm92aWRlciIsImNvbXBsZXRlIiwiZ2V0TmFtZSIsImV4ZWN1dGlvblRpbWUiLCJyZWNvcmRTdWNjZXNzIiwicmVjb3JkRmFpbHVyZSIsInByb3ZpZGVyTmFtZSIsImdldFByb3ZpZGVyIiwiZG9jdW1lbnRTaXplIiwiZXhjbHVkZVByb3ZpZGVycyIsImF2YWlsYWJsZVByb3ZpZGVycyIsImdldEF2YWlsYWJsZVByb3ZpZGVycyIsImxlbmd0aCIsInNlbGVjdGVkUHJvdmlkZXIiLCJzZWxlY3RQcm92aWRlckJ5U3RyYXRlZ3kiLCJtYXAiLCJwIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJpc0hlYWx0aHkiLCJwcmVmZXJyZWRPcmRlciIsImZpbmQiLCJyZWR1Y2UiLCJiZXN0IiwiY3VycmVudCIsImJlc3RIZWFsdGgiLCJjdXJyZW50SGVhbHRoIiwic2V0SW50ZXJ2YWwiLCJwZXJmb3JtSGVhbHRoQ2hlY2tzIiwiaW50ZXJ2YWwiLCJoZWFsdGhQcm9taXNlcyIsImVudHJpZXMiLCJoZWFsdGhDaGVjayIsImhlYWx0aHkiLCJyZXN1bHRzIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJyIiwic3RhdHVzIiwidmFsdWUiLCJyZWFzb24iLCJnZXRTeXN0ZW1IZWFsdGgiLCJwcm92aWRlclN0YXRzIiwiZ2V0U3RhdHMiLCJ0b3RhbFJlcXVlc3RzIiwic3VtIiwicmVxdWVzdENvdW50IiwidG90YWxFcnJvcnMiLCJlcnJvckNvdW50IiwiZmFpbG92ZXJTdGF0cyIsImdldEZhaWxvdmVyU3RhdHMiLCJ0b3RhbFByb3ZpZGVycyIsImVycm9yUmF0ZSIsImluaXRpYWxpemVQcm9tcHRWZXJzaW9uaW5nIiwiZXhlY3V0ZVdpdGhQcm9tcHQiLCJwcm9tcHRJZCIsInZhcmlhYmxlcyIsIm9wdGlvbnMiLCJwcm9tcHRWZXJzaW9uIiwiZXhlY3V0ZU9wdGlvbnMiLCJnZXRQcm9tcHQiLCJwcm9jZXNzZWRDb250ZW50Iiwic3Vic3RpdHV0ZVByb21wdFZhcmlhYmxlcyIsImNvbnRlbnQiLCJwcm9tcHRNZXRhZGF0YSIsInZlcnNpb24iLCJwcm9tcHRIYXNoIiwiZ2VuZXJhdGVQcm9tcHRIYXNoIiwidG9JU09TdHJpbmciLCJrZXkiLCJPYmplY3QiLCJyZWdleCIsIlJlZ0V4cCIsInJlcGxhY2UiLCJTdHJpbmciLCJ1bnN1YnN0aXR1dGVkIiwibWF0Y2giLCJwcm9tcHRDb250ZW50Iiwic3Vic3RyaW5nIiwiY3J5cHRvIiwiaGFzaERhdGEiLCJpZCIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJKU09OIiwic3RyaW5naWZ5IiwiZGlnZXN0Iiwic2F2ZVByb21wdCIsInByb21wdERhdGEiLCJsaXN0UHJvbXB0cyIsImdldFByb21wdFZlcnNpb25IaXN0b3J5IiwiZ2V0VmVyc2lvbkhpc3RvcnkiLCJyb2xsYmFja1Byb21wdCIsInRhcmdldFZlcnNpb24iLCJnZXRQcm9tcHRTdGF0aXN0aWNzIiwiZ2V0U3RhdGlzdGljcyIsInNodXRkb3duIiwiY2xlYXJJbnRlcnZhbCIsInNodXRkb3duUHJvbWlzZXMiLCJhbGwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiTExNUHJvdmlkZXJNYW5hZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTExNIFByb3ZpZGVyIE1hbmFnZXJcbiAqIFxuICogQ2VudHJhbCBtYW5hZ2VyIGZvciBhbGwgTExNIHByb3ZpZGVycyB3aXRoIGZhaWxvdmVyIGNhcGFiaWxpdGllcyxcbiAqIHByb3ZpZGVyIHNlbGVjdGlvbiBsb2dpYywgYW5kIGhlYWx0aCBtb25pdG9yaW5nLlxuICovXG5cbmNvbnN0IHsgQmFzZVByb3ZpZGVyLCBPcGVuQUlQcm92aWRlciwgQW50aHJvcGljUHJvdmlkZXIgfSA9IHJlcXVpcmUoJy4vcHJvdmlkZXJzJyk7XG5jb25zdCBGYWlsb3Zlck1hbmFnZXIgPSByZXF1aXJlKCcuL0ZhaWxvdmVyTWFuYWdlcicpO1xuY29uc3QgUHJvbXB0VmVyc2lvbk1hbmFnZXIgPSByZXF1aXJlKCcuL1Byb21wdFZlcnNpb25NYW5hZ2VyJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi91dGlscy9sb2dnZXInKTtcblxuY2xhc3MgTExNUHJvdmlkZXJNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGhlYWx0aENoZWNrSW50ZXJ2YWw6IDMwMDAwLCAvLyAzMCBzZWNvbmRzXG4gICAgICBtYXhDb25zZWN1dGl2ZUZhaWx1cmVzOiAzLFxuICAgICAgcHJvdmlkZXJUaW1lb3V0OiAzMDAwMCwgLy8gMzAgc2Vjb25kc1xuICAgICAgLi4uY29uZmlnXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnByb3ZpZGVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmhlYWx0aENoZWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuaXNTaHV0dGluZ0Rvd24gPSBmYWxzZTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHByb21wdCB2ZXJzaW9uIG1hbmFnZXJcbiAgICB0aGlzLnByb21wdFZlcnNpb25NYW5hZ2VyID0gbmV3IFByb21wdFZlcnNpb25NYW5hZ2VyKGNvbmZpZy5wcm9tcHRzIHx8IHt9KTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIGVuaGFuY2VkIGZhaWxvdmVyIG1hbmFnZXJcbiAgICB0aGlzLmZhaWxvdmVyTWFuYWdlciA9IG5ldyBGYWlsb3Zlck1hbmFnZXIoY29uZmlnLmZhaWxvdmVyIHx8IHt9KTtcbiAgICBcbiAgICAvLyBTZXQgdXAgZXZlbnQgbGlzdGVuZXJzIGZvciBmYWlsb3ZlciBldmVudHNcbiAgICB0aGlzLnNldHVwRmFpbG92ZXJFdmVudExpc3RlbmVycygpO1xuICAgIFxuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3ZpZGVycyhjb25maWcpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgZmFpbG92ZXIgbWFuYWdlciB3aXRoIHByb3ZpZGVyc1xuICAgIHRoaXMuZmFpbG92ZXJNYW5hZ2VyLmluaXRpYWxpemUodGhpcy5wcm92aWRlcnMpO1xuICAgIFxuICAgIHRoaXMuc3RhcnRIZWFsdGhNb25pdG9yaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIGV2ZW50IGxpc3RlbmVycyBmb3IgZmFpbG92ZXIgbWFuYWdlclxuICAgKi9cbiAgc2V0dXBGYWlsb3ZlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZmFpbG92ZXJNYW5hZ2VyLm9uKCdleGVjdXRpb25fc3VjY2VzcycsIChkYXRhKSA9PiB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1Byb3ZpZGVyIGV4ZWN1dGlvbiBzdWNjZWVkZWQnLCBkYXRhKTtcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmZhaWxvdmVyTWFuYWdlci5vbigncHJvdmlkZXJfZmFpbHVyZScsIChkYXRhKSA9PiB7XG4gICAgICBsb2dnZXIud2FybignUHJvdmlkZXIgZXhlY3V0aW9uIGZhaWxlZCcsIGRhdGEpO1xuICAgICAgLy8gVXBkYXRlIGxvY2FsIGhlYWx0aCB0cmFja2luZyB3aGVuIHByb3ZpZGVyIGZhaWxzXG4gICAgICB0aGlzLmhhbmRsZVByb3ZpZGVyRmFpbHVyZShkYXRhLnByb3ZpZGVyLCBuZXcgRXJyb3IoZGF0YS5lcnJvcikpO1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuZmFpbG92ZXJNYW5hZ2VyLm9uKCdhbGxfcHJvdmlkZXJzX2ZhaWxlZCcsIChkYXRhKSA9PiB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0FsbCBwcm92aWRlcnMgZmFpbGVkJywgZGF0YSk7XG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5mYWlsb3Zlck1hbmFnZXIub24oJ2NpcmN1aXRfYnJlYWtlcl9vcGVuZWQnLCAoZGF0YSkgPT4ge1xuICAgICAgbG9nZ2VyLmVycm9yKCdDaXJjdWl0IGJyZWFrZXIgb3BlbmVkIGZvciBwcm92aWRlcicsIGRhdGEpO1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuZmFpbG92ZXJNYW5hZ2VyLm9uKCdwcm92aWRlcl9yZWNvdmVyZWQnLCAoZGF0YSkgPT4ge1xuICAgICAgbG9nZ2VyLmluZm8oJ1Byb3ZpZGVyIHJlY292ZXJlZCBmcm9tIGZhaWx1cmUnLCBkYXRhKTtcbiAgICAgIC8vIFJlc2V0IGxvY2FsIGhlYWx0aCB0cmFja2luZyB3aGVuIHByb3ZpZGVyIHJlY292ZXJzXG4gICAgICBjb25zdCBoZWFsdGggPSB0aGlzLnByb3ZpZGVySGVhbHRoW2RhdGEucHJvdmlkZXJdO1xuICAgICAgaWYgKGhlYWx0aCkge1xuICAgICAgICBoZWFsdGguY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICAgIGhlYWx0aC5pc0F2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgIGhlYWx0aC5sYXN0RmFpbHVyZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpbml0aWFsaXplUHJvdmlkZXJzKGNvbmZpZykge1xuICAgIC8vIEluaXRpYWxpemUgT3BlbkFJIHByb3ZpZGVyIGlmIGNvbmZpZ3VyZWRcbiAgICBpZiAoY29uZmlnLm9wZW5haT8uYXBpS2V5KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBPcGVuQUlQcm92aWRlcihjb25maWcub3BlbmFpKTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KCdvcGVuYWknLCBwcm92aWRlcik7XG4gICAgICAgIC8vIEFsc28gc2V0IGFzIHByb3BlcnR5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggdGVzdHNcbiAgICAgICAgdGhpcy5wcm92aWRlcnMub3BlbmFpID0gcHJvdmlkZXI7XG4gICAgICAgIGxvZ2dlci5pbmZvKCdPcGVuQUkgcHJvdmlkZXIgaW5pdGlhbGl6ZWQnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgT3BlbkFJIHByb3ZpZGVyJywgeyBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIEFudGhyb3BpYyBwcm92aWRlciBpZiBjb25maWd1cmVkXG4gICAgaWYgKGNvbmZpZy5hbnRocm9waWM/LmFwaUtleSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgQW50aHJvcGljUHJvdmlkZXIoY29uZmlnLmFudGhyb3BpYyk7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldCgnYW50aHJvcGljJywgcHJvdmlkZXIpO1xuICAgICAgICAvLyBBbHNvIHNldCBhcyBwcm9wZXJ0eSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHRlc3RzXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLmFudGhyb3BpYyA9IHByb3ZpZGVyO1xuICAgICAgICBsb2dnZXIuaW5mbygnQW50aHJvcGljIHByb3ZpZGVyIGluaXRpYWxpemVkJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIEFudGhyb3BpYyBwcm92aWRlcicsIHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvdmlkZXJzLnNpemUgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gTExNIHByb3ZpZGVycyBjb25maWd1cmVkLiBQbGVhc2UgcHJvdmlkZSBBUEkga2V5cyBmb3IgYXQgbGVhc3Qgb25lIHByb3ZpZGVyLicpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcHJvdmlkZXIgaGVhbHRoIHRyYWNraW5nIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5wcm92aWRlckhlYWx0aCA9IHt9O1xuICAgIGZvciAoY29uc3QgW25hbWUsIHByb3ZpZGVyXSBvZiB0aGlzLnByb3ZpZGVycykge1xuICAgICAgdGhpcy5wcm92aWRlckhlYWx0aFtuYW1lXSA9IHtcbiAgICAgICAgY29uc2VjdXRpdmVGYWlsdXJlczogMCxcbiAgICAgICAgbGFzdEZhaWx1cmU6IG51bGwsXG4gICAgICAgIGlzQXZhaWxhYmxlOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY29tcGxldGlvbiByZXF1ZXN0IHdpdGggYXV0b21hdGljIGZhaWxvdmVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IC0gQ29tcGxldGlvbiByZXF1ZXN0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IENvbXBsZXRpb24gcmVzdWx0IHdpdGggbWV0YWRhdGFcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGUocmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVXaXRoRmFpbG92ZXIocmVxdWVzdCk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNvbXBsZXRpb24gcmVxdWVzdCB3aXRoIGF1dG9tYXRpYyBmYWlsb3ZlclxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCAtIENvbXBsZXRpb24gcmVxdWVzdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBDb21wbGV0aW9uIHJlc3VsdCB3aXRoIG1ldGFkYXRhXG4gICAqL1xuICBhc3luYyBleGVjdXRlV2l0aEZhaWxvdmVyKHJlcXVlc3QpIHtcbiAgICBpZiAodGhpcy5pc1NodXR0aW5nRG93bikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlciBtYW5hZ2VyIGlzIHNodXR0aW5nIGRvd24nKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHRhc2tUeXBlID0gJ2dlbmVyYWwnLCAuLi5jb21wbGV0aW9uUmVxdWVzdCB9ID0gcmVxdWVzdDtcbiAgICBcbiAgICBsb2dnZXIuaW5mbygnRXhlY3V0aW5nIGNvbXBsZXRpb24gcmVxdWVzdCcsIHtcbiAgICAgIHRhc2tUeXBlLFxuICAgICAgbW9kZWw6IGNvbXBsZXRpb25SZXF1ZXN0Lm1vZGVsLFxuICAgICAgaGFzUHJvbXB0OiAhIWNvbXBsZXRpb25SZXF1ZXN0LnByb21wdFxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFVzZSBlbmhhbmNlZCBmYWlsb3ZlciBtYW5hZ2VyIGZvciBleGVjdXRpb25cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZmFpbG92ZXJNYW5hZ2VyLmV4ZWN1dGVXaXRoRmFpbG92ZXIoY29tcGxldGlvblJlcXVlc3QpO1xuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gRW5oYW5jZSByZXN1bHQgd2l0aCBleHBlY3RlZCBtZXRhZGF0YVxuICAgICAgY29uc3QgZW5oYW5jZWRSZXN1bHQgPSB7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAuLi5yZXN1bHQubWV0YWRhdGEsXG4gICAgICAgICAgdG90YWxEdXJhdGlvbjogZW5kVGltZSAtIHN0YXJ0VGltZSxcbiAgICAgICAgICBleGVjdXRpb25UaW1lc3RhbXA6IGVuZFRpbWVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ0NvbXBsZXRpb24gcmVxdWVzdCBleGVjdXRlZCBzdWNjZXNzZnVsbHknLCB7XG4gICAgICAgIHByb3ZpZGVyOiByZXN1bHQucHJvdmlkZXIsXG4gICAgICAgIG1vZGVsOiByZXN1bHQubW9kZWwsXG4gICAgICAgIGNvc3Q6IHJlc3VsdC5jb3N0Py50b3RhbCB8fCAwLFxuICAgICAgICBkdXJhdGlvbjogZW5kVGltZSAtIHN0YXJ0VGltZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiBlbmhhbmNlZFJlc3VsdDtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0FsbCBwcm92aWRlcnMgZmFpbGVkIGZvciBjb21wbGV0aW9uIHJlcXVlc3QnLCB7XG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICB0YXNrVHlwZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHJlcXVlc3Qgd2l0aCBhIHNwZWNpZmljIHByb3ZpZGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm92aWRlciAtIFByb3ZpZGVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IC0gQ29tcGxldGlvbiByZXF1ZXN0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IENvbXBsZXRpb24gcmVzdWx0IHdpdGggbWV0YWRhdGFcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGVXaXRoUHJvdmlkZXIocHJvdmlkZXIsIHJlcXVlc3QpIHtcbiAgICBpZiAodGhpcy5pc1NodXR0aW5nRG93bikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlciBtYW5hZ2VyIGlzIHNodXR0aW5nIGRvd24nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmNvbXBsZXRlKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBwcm92aWRlciBtZXRhZGF0YVxuICAgICAgY29uc3QgZW5oYW5jZWRSZXN1bHQgPSB7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgcHJvdmlkZXI6IHByb3ZpZGVyLmdldE5hbWUoKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAuLi5yZXN1bHQubWV0YWRhdGEsXG4gICAgICAgICAgdG90YWxEdXJhdGlvbjogZW5kVGltZSAtIHN0YXJ0VGltZSxcbiAgICAgICAgICBleGVjdXRpb25UaW1lOiBlbmRUaW1lIC0gc3RhcnRUaW1lLFxuICAgICAgICAgIGV4ZWN1dGlvblRpbWVzdGFtcDogZW5kVGltZSxcbiAgICAgICAgICBwcm92aWRlcjogcHJvdmlkZXIuZ2V0TmFtZSgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFJlY29yZCBzdWNjZXNzIGluIGZhaWxvdmVyIG1hbmFnZXJcbiAgICAgIHRoaXMuZmFpbG92ZXJNYW5hZ2VyLnJlY29yZFN1Y2Nlc3MoXG4gICAgICAgIHByb3ZpZGVyLmdldE5hbWUoKSxcbiAgICAgICAgZW5kVGltZSAtIHN0YXJ0VGltZSxcbiAgICAgICAgcmVzdWx0LmNvc3Q/LnRvdGFsIHx8IDBcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiBlbmhhbmNlZFJlc3VsdDtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBFbmhhbmNlIGVycm9yIHdpdGggcHJvdmlkZXIgY29udGV4dFxuICAgICAgZXJyb3IucHJvdmlkZXIgPSBwcm92aWRlci5nZXROYW1lKCk7XG4gICAgICBlcnJvci5kdXJhdGlvbiA9IERhdGUubm93KCk7XG4gICAgICBlcnJvci5tZXNzYWdlID0gYFByb3ZpZGVyIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICAgIFxuICAgICAgLy8gUmVjb3JkIGZhaWx1cmUgaW4gZmFpbG92ZXIgbWFuYWdlclxuICAgICAgdGhpcy5mYWlsb3Zlck1hbmFnZXIucmVjb3JkRmFpbHVyZShwcm92aWRlci5nZXROYW1lKCksIGVycm9yKTtcbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwcm92aWRlciBmYWlsdXJlIGFuZCB1cGRhdGUgaGVhbHRoIHRyYWNraW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlck5hbWUgLSBOYW1lIG9mIHRoZSBmYWlsZWQgcHJvdmlkZXJcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBUaGUgZXJyb3IgdGhhdCBvY2N1cnJlZFxuICAgKi9cbiAgaGFuZGxlUHJvdmlkZXJGYWlsdXJlKHByb3ZpZGVyTmFtZSwgZXJyb3IpIHtcbiAgICBjb25zdCBoZWFsdGggPSB0aGlzLnByb3ZpZGVySGVhbHRoW3Byb3ZpZGVyTmFtZV07XG4gICAgaWYgKCFoZWFsdGgpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdBdHRlbXB0ZWQgdG8gaGFuZGxlIGZhaWx1cmUgZm9yIHVua25vd24gcHJvdmlkZXInLCB7IHByb3ZpZGVyTmFtZSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgaGVhbHRoLmNvbnNlY3V0aXZlRmFpbHVyZXMrKztcbiAgICBoZWFsdGgubGFzdEZhaWx1cmUgPSBuZXcgRGF0ZSgpO1xuICAgIFxuICAgIC8vIE1hcmsgcHJvdmlkZXIgYXMgdW5hdmFpbGFibGUgaWYgdG9vIG1hbnkgZmFpbHVyZXNcbiAgICBpZiAoaGVhbHRoLmNvbnNlY3V0aXZlRmFpbHVyZXMgPj0gdGhpcy5jb25maWcubWF4Q29uc2VjdXRpdmVGYWlsdXJlcykge1xuICAgICAgaGVhbHRoLmlzQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICBsb2dnZXIud2FybignUHJvdmlkZXIgbWFya2VkIGFzIHVuYXZhaWxhYmxlIGR1ZSB0byBjb25zZWN1dGl2ZSBmYWlsdXJlcycsIHtcbiAgICAgICAgcHJvdmlkZXI6IHByb3ZpZGVyTmFtZSxcbiAgICAgICAgY29uc2VjdXRpdmVGYWlsdXJlczogaGVhbHRoLmNvbnNlY3V0aXZlRmFpbHVyZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbHNvIHJlY29yZCBpbiBmYWlsb3ZlciBtYW5hZ2VyXG4gICAgdGhpcy5mYWlsb3Zlck1hbmFnZXIucmVjb3JkRmFpbHVyZShwcm92aWRlck5hbWUsIGVycm9yKTtcbiAgICBcbiAgICBsb2dnZXIuZGVidWcoJ1Byb3ZpZGVyIGZhaWx1cmUgcmVjb3JkZWQnLCB7XG4gICAgICBwcm92aWRlcjogcHJvdmlkZXJOYW1lLFxuICAgICAgY29uc2VjdXRpdmVGYWlsdXJlczogaGVhbHRoLmNvbnNlY3V0aXZlRmFpbHVyZXMsXG4gICAgICBpc0F2YWlsYWJsZTogaGVhbHRoLmlzQXZhaWxhYmxlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJlc3QgYXZhaWxhYmxlIHByb3ZpZGVyIGZvciBhIGdpdmVuIHRhc2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhc2tUeXBlIC0gVHlwZSBvZiB0YXNrIChlLmcuLCAnc3VtbWFyaXphdGlvbicsICdleHRyYWN0aW9uJylcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRvY3VtZW50U2l6ZSAtIFNpemUgb2YgZG9jdW1lbnQgaW4gY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGV4Y2x1ZGVQcm92aWRlcnMgLSBQcm92aWRlcnMgdG8gZXhjbHVkZSBmcm9tIHNlbGVjdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBTZWxlY3RlZCBwcm92aWRlclxuICAgKi9cbiAgYXN5bmMgZ2V0UHJvdmlkZXIodGFza1R5cGUgPSAnZ2VuZXJhbCcsIGRvY3VtZW50U2l6ZSA9IDAsIGV4Y2x1ZGVQcm92aWRlcnMgPSBbXSkge1xuICAgIGNvbnN0IGF2YWlsYWJsZVByb3ZpZGVycyA9IHRoaXMuZ2V0QXZhaWxhYmxlUHJvdmlkZXJzKGV4Y2x1ZGVQcm92aWRlcnMpO1xuICAgIFxuICAgIGlmIChhdmFpbGFibGVQcm92aWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGF2YWlsYWJsZSBwcm92aWRlcnMgZm9yIHRhc2sgZXhlY3V0aW9uJyk7XG4gICAgfVxuXG4gICAgLy8gUHJvdmlkZXIgc2VsZWN0aW9uIHN0cmF0ZWd5IGJhc2VkIG9uIHRhc2sgdHlwZSBhbmQgZG9jdW1lbnQgc2l6ZVxuICAgIGNvbnN0IHNlbGVjdGVkUHJvdmlkZXIgPSB0aGlzLnNlbGVjdFByb3ZpZGVyQnlTdHJhdGVneShcbiAgICAgIGF2YWlsYWJsZVByb3ZpZGVycyxcbiAgICAgIHRhc2tUeXBlLFxuICAgICAgZG9jdW1lbnRTaXplXG4gICAgKTtcblxuICAgIGxvZ2dlci5pbmZvKCdQcm92aWRlciBzZWxlY3RlZCBmb3IgdGFzaycsIHtcbiAgICAgIHByb3ZpZGVyOiBzZWxlY3RlZFByb3ZpZGVyLmdldE5hbWUoKSxcbiAgICAgIHRhc2tUeXBlLFxuICAgICAgZG9jdW1lbnRTaXplLFxuICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiBhdmFpbGFibGVQcm92aWRlcnMubWFwKHAgPT4gcC5nZXROYW1lKCkpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2VsZWN0ZWRQcm92aWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbGlzdCBvZiBhdmFpbGFibGUgKGhlYWx0aHkpIHByb3ZpZGVyc1xuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGV4Y2x1ZGVQcm92aWRlcnMgLSBQcm92aWRlcnMgdG8gZXhjbHVkZVxuICAgKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn0gQXZhaWxhYmxlIHByb3ZpZGVyIGluc3RhbmNlc1xuICAgKi9cbiAgZ2V0QXZhaWxhYmxlUHJvdmlkZXJzKGV4Y2x1ZGVQcm92aWRlcnMgPSBbXSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucHJvdmlkZXJzLnZhbHVlcygpKVxuICAgICAgLmZpbHRlcihwcm92aWRlciA9PiB7XG4gICAgICAgIGlmIChleGNsdWRlUHJvdmlkZXJzLmluY2x1ZGVzKHByb3ZpZGVyLmdldE5hbWUoKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGhlYWx0aCA9IHRoaXMucHJvdmlkZXJIZWFsdGhbcHJvdmlkZXIuZ2V0TmFtZSgpXTtcbiAgICAgICAgcmV0dXJuIGhlYWx0aD8uaXNBdmFpbGFibGUgJiYgcHJvdmlkZXIuaXNIZWFsdGh5O1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IHByb3ZpZGVyIGJhc2VkIG9uIHRhc2sgcmVxdWlyZW1lbnRzXG4gICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcHJvdmlkZXJzIC0gQXZhaWxhYmxlIHByb3ZpZGVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFza1R5cGUgLSBUYXNrIHR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRvY3VtZW50U2l6ZSAtIERvY3VtZW50IHNpemVcbiAgICogQHJldHVybnMge09iamVjdH0gU2VsZWN0ZWQgcHJvdmlkZXJcbiAgICovXG4gIHNlbGVjdFByb3ZpZGVyQnlTdHJhdGVneShwcm92aWRlcnMsIHRhc2tUeXBlLCBkb2N1bWVudFNpemUpIHtcbiAgICAvLyBTdHJhdGVneSAxOiBGb3IgbGFyZ2UgZG9jdW1lbnRzLCBwcmVmZXIgcHJvdmlkZXJzIHdpdGggaGlnaGVyIHRva2VuIGxpbWl0c1xuICAgIGlmIChkb2N1bWVudFNpemUgPiA1MDAwMCkge1xuICAgICAgY29uc3QgcHJlZmVycmVkT3JkZXIgPSBbJ2FudGhyb3BpYycsICdvcGVuYWknXTtcbiAgICAgIGZvciAoY29uc3QgcHJvdmlkZXJOYW1lIG9mIHByZWZlcnJlZE9yZGVyKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gcHJvdmlkZXJzLmZpbmQocCA9PiBwLmdldE5hbWUoKSA9PT0gcHJvdmlkZXJOYW1lKTtcbiAgICAgICAgaWYgKHByb3ZpZGVyKSByZXR1cm4gcHJvdmlkZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RyYXRlZ3kgMjogRm9yIGNvc3Qtc2Vuc2l0aXZlIHRhc2tzLCBwcmVmZXIgY2hlYXBlciBwcm92aWRlcnNcbiAgICBpZiAodGFza1R5cGUgPT09ICdidWxrX3Byb2Nlc3NpbmcnKSB7XG4gICAgICBjb25zdCBwcmVmZXJyZWRPcmRlciA9IFsnYW50aHJvcGljJywgJ29wZW5haSddOyAvLyBBbnRocm9waWMgSGFpa3UgaXMgY2hlYXBlclxuICAgICAgZm9yIChjb25zdCBwcm92aWRlck5hbWUgb2YgcHJlZmVycmVkT3JkZXIpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBwcm92aWRlcnMuZmluZChwID0+IHAuZ2V0TmFtZSgpID09PSBwcm92aWRlck5hbWUpO1xuICAgICAgICBpZiAocHJvdmlkZXIpIHJldHVybiBwcm92aWRlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdHJhdGVneSAzOiBGb3IgaGlnaC1xdWFsaXR5IHRhc2tzLCBwcmVmZXIgcHJlbWl1bSBtb2RlbHNcbiAgICBpZiAodGFza1R5cGUgPT09ICdjcml0aWNhbF9hbmFseXNpcycpIHtcbiAgICAgIGNvbnN0IHByZWZlcnJlZE9yZGVyID0gWydvcGVuYWknLCAnYW50aHJvcGljJ107IC8vIEdQVC00IGZvciBjcml0aWNhbCB0YXNrc1xuICAgICAgZm9yIChjb25zdCBwcm92aWRlck5hbWUgb2YgcHJlZmVycmVkT3JkZXIpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBwcm92aWRlcnMuZmluZChwID0+IHAuZ2V0TmFtZSgpID09PSBwcm92aWRlck5hbWUpO1xuICAgICAgICBpZiAocHJvdmlkZXIpIHJldHVybiBwcm92aWRlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0OiBSZXR1cm4gcHJvdmlkZXIgd2l0aCBsb3dlc3QgZXJyb3IgcmF0ZVxuICAgIHJldHVybiBwcm92aWRlcnMucmVkdWNlKChiZXN0LCBjdXJyZW50KSA9PiB7XG4gICAgICBjb25zdCBiZXN0SGVhbHRoID0gdGhpcy5wcm92aWRlckhlYWx0aFtiZXN0LmdldE5hbWUoKV07XG4gICAgICBjb25zdCBjdXJyZW50SGVhbHRoID0gdGhpcy5wcm92aWRlckhlYWx0aFtjdXJyZW50LmdldE5hbWUoKV07XG4gICAgICBcbiAgICAgIHJldHVybiBjdXJyZW50SGVhbHRoLmNvbnNlY3V0aXZlRmFpbHVyZXMgPCBiZXN0SGVhbHRoLmNvbnNlY3V0aXZlRmFpbHVyZXMgXG4gICAgICAgID8gY3VycmVudCBcbiAgICAgICAgOiBiZXN0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHBlcmlvZGljIGhlYWx0aCBtb25pdG9yaW5nXG4gICAqL1xuICBzdGFydEhlYWx0aE1vbml0b3JpbmcoKSB7XG4gICAgLy8gU2tpcCBoZWFsdGggbW9uaXRvcmluZyBpZiBpbnRlcnZhbCBpcyAwIChmb3IgdGVzdGluZylcbiAgICBpZiAodGhpcy5jb25maWcuaGVhbHRoQ2hlY2tJbnRlcnZhbCA9PT0gMCkge1xuICAgICAgbG9nZ2VyLmluZm8oJ0hlYWx0aCBtb25pdG9yaW5nIGRpc2FibGVkIChpbnRlcnZhbCA9IDApJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMucGVyZm9ybUhlYWx0aENoZWNrcygpO1xuICAgIH0sIHRoaXMuY29uZmlnLmhlYWx0aENoZWNrSW50ZXJ2YWwpO1xuXG4gICAgbG9nZ2VyLmluZm8oJ0hlYWx0aCBtb25pdG9yaW5nIHN0YXJ0ZWQnLCB7XG4gICAgICBpbnRlcnZhbDogdGhpcy5jb25maWcuaGVhbHRoQ2hlY2tJbnRlcnZhbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gaGVhbHRoIGNoZWNrcyBvbiBhbGwgcHJvdmlkZXJzXG4gICAqL1xuICBhc3luYyBwZXJmb3JtSGVhbHRoQ2hlY2tzKCkge1xuICAgIGNvbnN0IGhlYWx0aFByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy5lbnRyaWVzKCkpLm1hcChhc3luYyAoW25hbWUsIHByb3ZpZGVyXSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaGVhbHRoID0gYXdhaXQgcHJvdmlkZXIuaGVhbHRoQ2hlY2soKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChoZWFsdGguaGVhbHRoeSkge1xuICAgICAgICAgIC8vIFJlc2V0IGF2YWlsYWJpbGl0eSBpZiBwcm92aWRlciBpcyBoZWFsdGh5IGFnYWluXG4gICAgICAgICAgdGhpcy5wcm92aWRlckhlYWx0aFtuYW1lXS5pc0F2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5wcm92aWRlckhlYWx0aFtuYW1lXS5jb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IG5hbWUsIGhlYWx0aCB9O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdIZWFsdGggY2hlY2sgZmFpbGVkJywgeyBwcm92aWRlcjogbmFtZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICAgIHJldHVybiB7IG5hbWUsIGhlYWx0aDogeyBoZWFsdGh5OiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChoZWFsdGhQcm9taXNlcyk7XG4gICAgXG4gICAgbG9nZ2VyLmRlYnVnKCdIZWFsdGggY2hlY2sgY29tcGxldGVkJywge1xuICAgICAgcmVzdWx0czogcmVzdWx0cy5tYXAociA9PiByLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgPyByLnZhbHVlIDogeyBlcnJvcjogci5yZWFzb24gfSlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc3lzdGVtIGhlYWx0aCBhbmQgc3RhdGlzdGljc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFsdGggYW5kIHN0YXRzIHN1bW1hcnlcbiAgICovXG4gIGdldFN5c3RlbUhlYWx0aCgpIHtcbiAgICBjb25zdCBwcm92aWRlclN0YXRzID0gQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy5lbnRyaWVzKCkpLm1hcCgoW25hbWUsIHByb3ZpZGVyXSkgPT4gKHtcbiAgICAgIG5hbWUsXG4gICAgICAuLi5wcm92aWRlci5nZXRTdGF0cygpLFxuICAgICAgaGVhbHRoOiB0aGlzLnByb3ZpZGVySGVhbHRoW25hbWVdXG4gICAgfSkpO1xuICAgIFxuICAgIGNvbnN0IHRvdGFsUmVxdWVzdHMgPSBwcm92aWRlclN0YXRzLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLnJlcXVlc3RDb3VudCwgMCk7XG4gICAgY29uc3QgdG90YWxFcnJvcnMgPSBwcm92aWRlclN0YXRzLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLmVycm9yQ291bnQsIDApO1xuICAgIGNvbnN0IGF2YWlsYWJsZVByb3ZpZGVycyA9IHByb3ZpZGVyU3RhdHMuZmlsdGVyKHAgPT4gcC5oZWFsdGguaXNBdmFpbGFibGUpLmxlbmd0aDtcblxuICAgIC8vIEdldCBlbmhhbmNlZCBmYWlsb3ZlciBzdGF0aXN0aWNzXG4gICAgY29uc3QgZmFpbG92ZXJTdGF0cyA9IHRoaXMuZmFpbG92ZXJNYW5hZ2VyLmdldEZhaWxvdmVyU3RhdHMoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbFByb3ZpZGVyczogdGhpcy5wcm92aWRlcnMuc2l6ZSxcbiAgICAgIGF2YWlsYWJsZVByb3ZpZGVycyxcbiAgICAgIHRvdGFsUmVxdWVzdHMsXG4gICAgICB0b3RhbEVycm9ycyxcbiAgICAgIGVycm9yUmF0ZTogdG90YWxSZXF1ZXN0cyA+IDAgPyAodG90YWxFcnJvcnMgLyB0b3RhbFJlcXVlc3RzKSA6IDAsXG4gICAgICBwcm92aWRlcnM6IHByb3ZpZGVyU3RhdHMsXG4gICAgICBmYWlsb3ZlcjogZmFpbG92ZXJTdGF0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBwcm9tcHQgdmVyc2lvbiBtYW5hZ2VyXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplUHJvbXB0VmVyc2lvbmluZygpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5wcm9tcHRWZXJzaW9uTWFuYWdlci5pbml0aWFsaXplKCk7XG4gICAgICBsb2dnZXIuaW5mbygnUHJvbXB0IHZlcnNpb25pbmcgc3lzdGVtIGluaXRpYWxpemVkJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgcHJvbXB0IHZlcnNpb25pbmcnLCB7IGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgZW5yaWNobWVudCB3aXRoIHZlcnNpb25lZCBwcm9tcHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb21wdElkIC0gSUQgb2YgdGhlIHByb21wdCB0byB1c2VcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhcmlhYmxlcyAtIFZhcmlhYmxlcyB0byBzdWJzdGl0dXRlIGluIHRoZSBwcm9tcHRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBFeGVjdXRpb24gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBFbnJpY2htZW50IHJlc3VsdCB3aXRoIHByb21wdCBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZVdpdGhQcm9tcHQocHJvbXB0SWQsIHZhcmlhYmxlcyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwcm9tcHRWZXJzaW9uID0gJ2xhdGVzdCcsXG4gICAgICAgIHByb3ZpZGVyID0gbnVsbCxcbiAgICAgICAgdGFza1R5cGUgPSAnZW5yaWNobWVudCcsXG4gICAgICAgIC4uLmV4ZWN1dGVPcHRpb25zXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgLy8gR2V0IHRoZSB2ZXJzaW9uZWQgcHJvbXB0XG4gICAgICBjb25zdCBwcm9tcHQgPSBhd2FpdCB0aGlzLnByb21wdFZlcnNpb25NYW5hZ2VyLmdldFByb21wdChwcm9tcHRJZCwgcHJvbXB0VmVyc2lvbik7XG4gICAgICBpZiAoIXByb21wdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb21wdCBub3QgZm91bmQ6ICR7cHJvbXB0SWR9ICh2ZXJzaW9uOiAke3Byb21wdFZlcnNpb259KWApO1xuICAgICAgfVxuXG4gICAgICAvLyBTdWJzdGl0dXRlIHZhcmlhYmxlcyBpbiBwcm9tcHQgY29udGVudFxuICAgICAgY29uc3QgcHJvY2Vzc2VkQ29udGVudCA9IHRoaXMuc3Vic3RpdHV0ZVByb21wdFZhcmlhYmxlcyhwcm9tcHQuY29udGVudCwgdmFyaWFibGVzKTtcblxuICAgICAgLy8gRXhlY3V0ZSB3aXRoIGZhaWxvdmVyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVXaXRoRmFpbG92ZXIoe1xuICAgICAgICB0YXNrVHlwZSxcbiAgICAgICAgcHJvbXB0OiBwcm9jZXNzZWRDb250ZW50LFxuICAgICAgICAuLi5leGVjdXRlT3B0aW9uc1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCBwcm9tcHQgbWV0YWRhdGEgdG8gcmVzdWx0XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIHByb21wdE1ldGFkYXRhOiB7XG4gICAgICAgICAgcHJvbXB0SWQsXG4gICAgICAgICAgcHJvbXB0VmVyc2lvbjogcHJvbXB0LnZlcnNpb24sXG4gICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgIHByb21wdEhhc2g6IHRoaXMuZ2VuZXJhdGVQcm9tcHRIYXNoKHByb21wdCksXG4gICAgICAgICAgZXhlY3V0aW9uVGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSB3aXRoIHByb21wdCcsIHtcbiAgICAgICAgcHJvbXB0SWQsXG4gICAgICAgIHByb21wdFZlcnNpb246IG9wdGlvbnMucHJvbXB0VmVyc2lvbixcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnN0aXR1dGUgdmFyaWFibGVzIGluIHByb21wdCBjb250ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IC0gUHJvbXB0IGNvbnRlbnQgd2l0aCB2YXJpYWJsZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhcmlhYmxlcyAtIFZhcmlhYmxlcyB0byBzdWJzdGl0dXRlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFByb2Nlc3NlZCBjb250ZW50XG4gICAqL1xuICBzdWJzdGl0dXRlUHJvbXB0VmFyaWFibGVzKGNvbnRlbnQsIHZhcmlhYmxlcykge1xuICAgIGxldCBwcm9jZXNzZWRDb250ZW50ID0gY29udGVudDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YXJpYWJsZXMpKSB7XG4gICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYFxcXFx7XFxcXHske2tleX1cXFxcfVxcXFx9YCwgJ2cnKTtcbiAgICAgIHByb2Nlc3NlZENvbnRlbnQgPSBwcm9jZXNzZWRDb250ZW50LnJlcGxhY2UocmVnZXgsIFN0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciB1bnN1YnN0aXR1dGVkIHZhcmlhYmxlc1xuICAgIGNvbnN0IHVuc3Vic3RpdHV0ZWQgPSBwcm9jZXNzZWRDb250ZW50Lm1hdGNoKC9cXHtcXHtcXHcrXFx9XFx9L2cpO1xuICAgIGlmICh1bnN1YnN0aXR1dGVkKSB7XG4gICAgICBsb2dnZXIud2FybignVW5zdWJzdGl0dXRlZCB2YXJpYWJsZXMgZm91bmQgaW4gcHJvbXB0JywgeyBcbiAgICAgICAgdmFyaWFibGVzOiB1bnN1YnN0aXR1dGVkLFxuICAgICAgICBwcm9tcHRDb250ZW50OiBwcm9jZXNzZWRDb250ZW50LnN1YnN0cmluZygwLCAxMDApICsgJy4uLidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9jZXNzZWRDb250ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGhhc2ggZm9yIHByb21wdCByZXByb2R1Y2liaWxpdHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb21wdCAtIFByb21wdCBvYmplY3RcbiAgICogQHJldHVybnMge3N0cmluZ30gSGFzaCBzdHJpbmdcbiAgICovXG4gIGdlbmVyYXRlUHJvbXB0SGFzaChwcm9tcHQpIHtcbiAgICBjb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgICBjb25zdCBoYXNoRGF0YSA9IHtcbiAgICAgIGlkOiBwcm9tcHQuaWQsXG4gICAgICB2ZXJzaW9uOiBwcm9tcHQudmVyc2lvbixcbiAgICAgIGNvbnRlbnQ6IHByb21wdC5jb250ZW50XG4gICAgfTtcbiAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShKU09OLnN0cmluZ2lmeShoYXNoRGF0YSkpLmRpZ2VzdCgnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZSBvciB1cGRhdGUgYSBwcm9tcHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb21wdElkIC0gUHJvbXB0IGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb21wdERhdGEgLSBQcm9tcHQgY29udGVudCBhbmQgbWV0YWRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBTYXZlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gU2F2ZWQgcHJvbXB0XG4gICAqL1xuICBhc3luYyBzYXZlUHJvbXB0KHByb21wdElkLCBwcm9tcHREYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvbXB0VmVyc2lvbk1hbmFnZXIuc2F2ZVByb21wdChwcm9tcHRJZCwgcHJvbXB0RGF0YSwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHNhdmUgcHJvbXB0JywgeyBwcm9tcHRJZCwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcHJvbXB0IGJ5IElEIGFuZCB2ZXJzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9tcHRJZCAtIFByb21wdCBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uIC0gUHJvbXB0IHZlcnNpb24gKGRlZmF1bHQ6ICdsYXRlc3QnKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8bnVsbD59IFByb21wdCBvYmplY3Qgb3IgbnVsbFxuICAgKi9cbiAgYXN5bmMgZ2V0UHJvbXB0KHByb21wdElkLCB2ZXJzaW9uID0gJ2xhdGVzdCcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvbXB0VmVyc2lvbk1hbmFnZXIuZ2V0UHJvbXB0KHByb21wdElkLCB2ZXJzaW9uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZ2V0IHByb21wdCcsIHsgcHJvbXB0SWQsIHZlcnNpb24sIGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgYWxsIGF2YWlsYWJsZSBwcm9tcHRzXG4gICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBBcnJheSBvZiBwcm9tcHQgSURzXG4gICAqL1xuICBsaXN0UHJvbXB0cygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9tcHRWZXJzaW9uTWFuYWdlci5saXN0UHJvbXB0cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB2ZXJzaW9uIGhpc3RvcnkgZm9yIGEgcHJvbXB0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9tcHRJZCAtIFByb21wdCBpZGVudGlmaWVyXG4gICAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSBWZXJzaW9uIGhpc3RvcnlcbiAgICovXG4gIGdldFByb21wdFZlcnNpb25IaXN0b3J5KHByb21wdElkKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvbXB0VmVyc2lvbk1hbmFnZXIuZ2V0VmVyc2lvbkhpc3RvcnkocHJvbXB0SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvbGxiYWNrIHByb21wdCB0byBhIHByZXZpb3VzIHZlcnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb21wdElkIC0gUHJvbXB0IGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFZlcnNpb24gLSBUYXJnZXQgdmVyc2lvbiB0byByb2xsYmFjayB0b1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBSb2xsYmFjayByZXN1bHRcbiAgICovXG4gIGFzeW5jIHJvbGxiYWNrUHJvbXB0KHByb21wdElkLCB0YXJnZXRWZXJzaW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb21wdFZlcnNpb25NYW5hZ2VyLnJvbGxiYWNrUHJvbXB0KHByb21wdElkLCB0YXJnZXRWZXJzaW9uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcm9sbGJhY2sgcHJvbXB0JywgeyBwcm9tcHRJZCwgdGFyZ2V0VmVyc2lvbiwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHByb21wdCB2ZXJzaW9uaW5nIHN0YXRpc3RpY3NcbiAgICogQHJldHVybnMge09iamVjdH0gU3RhdGlzdGljc1xuICAgKi9cbiAgZ2V0UHJvbXB0U3RhdGlzdGljcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9tcHRWZXJzaW9uTWFuYWdlci5nZXRTdGF0aXN0aWNzKCk7XG4gIH1cblxuICAvKipcbiAgICogR3JhY2VmdWxseSBzaHV0ZG93biB0aGUgcHJvdmlkZXIgbWFuYWdlclxuICAgKi9cbiAgYXN5bmMgc2h1dGRvd24oKSB7XG4gICAgdGhpcy5pc1NodXR0aW5nRG93biA9IHRydWU7XG4gICAgXG4gICAgbG9nZ2VyLmluZm8oJ1NodXR0aW5nIGRvd24gTExNIFByb3ZpZGVyIE1hbmFnZXInKTtcbiAgICBcbiAgICAvLyBTdG9wIGhlYWx0aCBtb25pdG9yaW5nXG4gICAgaWYgKHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYWx0aENoZWNrSW50ZXJ2YWwpO1xuICAgICAgdGhpcy5oZWFsdGhDaGVja0ludGVydmFsID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gU2h1dGRvd24gZmFpbG92ZXIgbWFuYWdlclxuICAgIGF3YWl0IHRoaXMuZmFpbG92ZXJNYW5hZ2VyLnNodXRkb3duKCk7XG4gICAgXG4gICAgLy8gU2h1dGRvd24gcHJvbXB0IHZlcnNpb24gbWFuYWdlclxuICAgIGF3YWl0IHRoaXMucHJvbXB0VmVyc2lvbk1hbmFnZXIuc2h1dGRvd24oKTtcbiAgICBcbiAgICAvLyBTaHV0ZG93biBhbGwgcHJvdmlkZXJzXG4gICAgY29uc3Qgc2h1dGRvd25Qcm9taXNlcyA9IEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpLm1hcChhc3luYyAocHJvdmlkZXIpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXIuc2h1dGRvd24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBhd2FpdCBwcm92aWRlci5zaHV0ZG93bigpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHNodXR0aW5nIGRvd24gcHJvdmlkZXInLCB7XG4gICAgICAgICAgcHJvdmlkZXI6IHByb3ZpZGVyLmdldE5hbWUoKSxcbiAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBhd2FpdCBQcm9taXNlLmFsbChzaHV0ZG93blByb21pc2VzKTtcbiAgICBcbiAgICBsb2dnZXIuaW5mbygnTExNIFByb3ZpZGVyIE1hbmFnZXIgc2h1dGRvd24gY29tcGxldGUnKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExMTVByb3ZpZGVyTWFuYWdlcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07RUFBRUEsWUFBWTtFQUFFQyxjQUFjO0VBQUVDO0FBQWtCLENBQUMsR0FBR0MsT0FBTyxDQUFDLGFBQWEsQ0FBQztBQUNsRixNQUFNQyxlQUFlLEdBQUdELE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQztBQUNwRCxNQUFNRSxvQkFBb0IsR0FBR0YsT0FBTyxDQUFDLHdCQUF3QixDQUFDO0FBQzlELE1BQU1HLE1BQU0sR0FBR0gsT0FBTyxDQUFDLGlCQUFpQixDQUFDO0FBRXpDLE1BQU1JLGtCQUFrQixDQUFDO0VBQ3ZCQyxXQUFXQSxDQUFDQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUU7SUFDdkIsSUFBSSxDQUFDQSxNQUFNLEdBQUc7TUFDWkMsbUJBQW1CLEVBQUUsS0FBSztNQUFFO01BQzVCQyxzQkFBc0IsRUFBRSxDQUFDO01BQ3pCQyxlQUFlLEVBQUUsS0FBSztNQUFFO01BQ3hCLEdBQUdIO0lBQ0wsQ0FBQztJQUVELElBQUksQ0FBQ0ksU0FBUyxHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLElBQUksQ0FBQ0osbUJBQW1CLEdBQUcsSUFBSTtJQUMvQixJQUFJLENBQUNLLGNBQWMsR0FBRyxLQUFLOztJQUUzQjtJQUNBLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsSUFBSVgsb0JBQW9CLENBQUNJLE1BQU0sQ0FBQ1EsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDOztJQUUxRTtJQUNBLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUlkLGVBQWUsQ0FBQ0ssTUFBTSxDQUFDVSxRQUFRLElBQUksQ0FBQyxDQUFDLENBQUM7O0lBRWpFO0lBQ0EsSUFBSSxDQUFDQywyQkFBMkIsQ0FBQyxDQUFDO0lBRWxDLElBQUksQ0FB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RWxJLEtBQUssRUFBRUEsS0FBSyxDQUFDVTtNQUFRLENBQUMsQ0FBQztNQUM1RixNQUFNVixLQUFLO0lBQ2I7RUFDRjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFbUksbUJBQW1CQSxDQUFBLEVBQUc7SUFDcEIsT0FBTyxJQUFJLENBQUNsSixvQkFBb0IsQ0FBQ21KLGFBQWEsQ0FBQyxDQUFDO0VBQ2xEOztFQUVBO0FBQ0Y7QUFDQTtFQUNFLE1BQU1DLFFBQVFBLENBQUEsRUFBRztJQUNmLElBQUksQ0FBQ3JKLGNBQWMsR0FBRyxJQUFJO0lBRTFCVCxNQUFNLENBQUMwQixJQUFJLENBQUMsb0NBQW9DLENBQUM7O0lBRWpEO0lBQ0EsSUFBSSxJQUFJLENBQUN0QixtQkFBbUIsRUFBRTtNQUM1QjJKLGFBQWEsQ0FBQyxJQUFJLENBQUMzSixtQkFBbUIsQ0FBQztNQUN2QyxJQUFJLENBQUNBLG1CQUFtQixHQUFHLElBQUk7SUFDakM7O0lBRUE7SUFDQSxNQUFNLElBQUksQ0FBQ1EsZUFBZSxDQUFDa0osUUFBUSxDQUFDLENBQUM7O0lBRXJDO0lBQ0EsTUFBTSxJQUFJLENBQUNwSixvQkFBb0IsQ0FBQ29KLFFBQVEsQ0FBQyxDQUFDOztJQUUxQztJQUNBLE1BQU1FLGdCQUFnQixHQUFHcEYsS0FBSyxDQUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDdEUsU0FBUyxDQUFDdUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDSixHQUFHLENBQUMsTUFBT25ELFFBQVEsSUFBSztNQUNuRixJQUFJO1FBQ0YsSUFBSSxPQUFPQSxRQUFRLENBQUN1SSxRQUFRLEtBQUssVUFBVSxFQUFFO1VBQzNDLE1BQU12SSxRQUFRLENBQUN1SSxRQUFRLENBQUMsQ0FBQztRQUMzQjtNQUNGLENBQUMsQ0FBQyxPQUFPckksS0FBSyxFQUFFO1FBQ2R6QixNQUFNLENBQUN5QixLQUFLLENBQUMsOEJBQThCLEVBQUU7VUFDM0NGLFFBQVEsRUFBRUEsUUFBUSxDQUFDc0MsT0FBTyxDQUFDLENBQUM7VUFDNUJwQyxLQUFLLEVBQUVBLEtBQUssQ0FBQ1U7UUFDZixDQUFDLENBQUM7TUFDSjtJQUNGLENBQUMsQ0FBQztJQUVGLE1BQU04RCxPQUFPLENBQUNnRSxHQUFHLENBQUNELGdCQUFnQixDQUFDO0lBRW5DaEssTUFBTSxDQUFDMEIsSUFBSSxDQUFDLHdDQUF3QyxDQUFDO0VBQ3ZEO0FBQ0Y7QUFFQXdJLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHbEssa0JBQWtCIiwiaWdub3JlTGlzdCI6W119