{"version":3,"names":["BaseProvider","OpenAIProvider","AnthropicProvider","require","FailoverManager","PromptVersionManager","logger","LLMProviderManager","constructor","config","healthCheckInterval","maxConsecutiveFailures","providerTimeout","providers","Map","isShuttingDown","promptVersionManager","prompts","failoverManager","failover","setupFailoverEventListeners","initializeProviders","initialize","startHealthMonitoring","on","data","debug","warn","handleProviderFailure","provider","Error","error","info","health","providerHealth","consecutiveFailures","isAvailable","lastFailure","openai","apiKey","set","message","anthropic","size","name","execute","request","executeWithFailover","taskType","completionRequest","model","hasPrompt","prompt","startTime","Date","now","result","endTime","enhancedResult","metadata","totalDuration","executionTimestamp","cost","total","duration","executeWithProvider","complete","getName","executionTime","recordSuccess","recordFailure","providerName","getProvider","documentSize","excludeProviders","availableProviders","getAvailableProviders","length","selectedProvider","selectProviderByStrategy","map","p","Array","from","values","filter","includes","isHealthy","preferredOrder","find","reduce","best","current","bestHealth","currentHealth","setInterval","performHealthChecks","interval","healthPromises","entries","healthCheck","healthy","results","Promise","allSettled","r","status","value","reason","getSystemHealth","providerStats","getStats","totalRequests","sum","requestCount","totalErrors","errorCount","failoverStats","getFailoverStats","totalProviders","errorRate","initializePromptVersioning","executeWithPrompt","promptId","variables","options","promptVersion","executeOptions","getPrompt","processedContent","substitutePromptVariables","content","promptMetadata","version","promptHash","generatePromptHash","toISOString","key","Object","regex","RegExp","replace","String","unsubstituted","match","promptContent","substring","crypto","hashData","id","createHash","update","JSON","stringify","digest","savePrompt","promptData","listPrompts","getPromptVersionHistory","getVersionHistory","rollbackPrompt","targetVersion","getPromptStatistics","getStatistics","shutdown","clearInterval","shutdownPromises","all","module","exports"],"sources":["LLMProviderManager.js"],"sourcesContent":["/**\n * LLM Provider Manager\n * \n * Central manager for all LLM providers with failover capabilities,\n * provider selection logic, and health monitoring.\n */\n\nconst { BaseProvider, OpenAIProvider, AnthropicProvider } = require('./providers');\nconst FailoverManager = require('./FailoverManager');\nconst PromptVersionManager = require('./PromptVersionManager');\nconst logger = require('../utils/logger');\n\nclass LLMProviderManager {\n  constructor(config = {}) {\n    this.config = {\n      healthCheckInterval: 30000, // 30 seconds\n      maxConsecutiveFailures: 3,\n      providerTimeout: 30000, // 30 seconds\n      ...config\n    };\n    \n    this.providers = new Map();\n    this.healthCheckInterval = null;\n    this.isShuttingDown = false;\n    \n    // Initialize prompt version manager\n    this.promptVersionManager = new PromptVersionManager(config.prompts || {});\n    \n    // Initialize enhanced failover manager\n    this.failoverManager = new FailoverManager(config.failover || {});\n    \n    // Set up event listeners for failover events\n    this.setupFailoverEventListeners();\n    \n    this.initializeProviders(config);\n    \n    // Initialize failover manager with providers\n    this.failoverManager.initialize(this.providers);\n    \n    this.startHealthMonitoring();\n  }\n\n  /**\n   * Set up event listeners for failover manager\n   */\n  setupFailoverEventListeners() {\n    this.failoverManager.on('execution_success', (data) => {\n      logger.debug('Provider execution succeeded', data);\n    });\n    \n    this.failoverManager.on('provider_failure', (data) => {\n      logger.warn('Provider execution failed', data);\n      // Update local health tracking when provider fails\n      this.handleProviderFailure(data.provider, new Error(data.error));\n    });\n    \n    this.failoverManager.on('all_providers_failed', (data) => {\n      logger.error('All providers failed', data);\n    });\n    \n    this.failoverManager.on('circuit_breaker_opened', (data) => {\n      logger.error('Circuit breaker opened for provider', data);\n    });\n    \n    this.failoverManager.on('provider_recovered', (data) => {\n      logger.info('Provider recovered from failure', data);\n      // Reset local health tracking when provider recovers\n      const health = this.providerHealth[data.provider];\n      if (health) {\n        health.consecutiveFailures = 0;\n        health.isAvailable = true;\n        health.lastFailure = null;\n      }\n    });\n  }\n\n  initializeProviders(config) {\n    // Initialize OpenAI provider if configured\n    if (config.openai?.apiKey) {\n      try {\n        const provider = new OpenAIProvider(config.openai);\n        this.providers.set('openai', provider);\n        // Also set as property for backward compatibility with tests\n        this.providers.openai = provider;\n        logger.info('OpenAI provider initialized');\n      } catch (error) {\n        logger.error('Failed to initialize OpenAI provider', { error: error.message });\n      }\n    }\n\n    // Initialize Anthropic provider if configured\n    if (config.anthropic?.apiKey) {\n      try {\n        const provider = new AnthropicProvider(config.anthropic);\n        this.providers.set('anthropic', provider);\n        // Also set as property for backward compatibility with tests\n        this.providers.anthropic = provider;\n        logger.info('Anthropic provider initialized');\n      } catch (error) {\n        logger.error('Failed to initialize Anthropic provider', { error: error.message });\n      }\n    }\n\n    if (this.providers.size === 0) {\n      throw new Error('No LLM providers configured. Please provide API keys for at least one provider.');\n    }\n\n    // Initialize provider health tracking for backward compatibility\n    this.providerHealth = {};\n    for (const [name, provider] of this.providers) {\n      this.providerHealth[name] = {\n        consecutiveFailures: 0,\n        lastFailure: null,\n        isAvailable: true\n      };\n    }\n  }\n\n  /**\n   * Execute a completion request with automatic failover\n   * @param {Object} request - Completion request\n   * @returns {Promise<Object>} Completion result with metadata\n   */\n  async execute(request) {\n    return this.executeWithFailover(request);\n  }\n\n  /**\n   * Execute a completion request with automatic failover\n   * @param {Object} request - Completion request\n   * @returns {Promise<Object>} Completion result with metadata\n   */\n  async executeWithFailover(request) {\n    if (this.isShuttingDown) {\n      throw new Error('Provider manager is shutting down');\n    }\n\n    const { taskType = 'general', ...completionRequest } = request;\n    \n    logger.info('Executing completion request', {\n      taskType,\n      model: completionRequest.model,\n      hasPrompt: !!completionRequest.prompt\n    });\n\n    try {\n      const startTime = Date.now();\n      \n      // Use enhanced failover manager for execution\n      const result = await this.failoverManager.executeWithFailover(completionRequest);\n      \n      const endTime = Date.now();\n      \n      // Enhance result with expected metadata\n      const enhancedResult = {\n        ...result,\n        metadata: {\n          ...result.metadata,\n          totalDuration: endTime - startTime,\n          executionTimestamp: endTime\n        }\n      };\n      \n      logger.info('Completion request executed successfully', {\n        provider: result.provider,\n        model: result.model,\n        cost: result.cost?.total || 0,\n        duration: endTime - startTime\n      });\n      \n      return enhancedResult;\n      \n    } catch (error) {\n      logger.error('All providers failed for completion request', {\n        error: error.message,\n        taskType\n      });\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Execute request with a specific provider\n   * @param {Object} provider - Provider instance\n   * @param {Object} request - Completion request\n   * @returns {Promise<Object>} Completion result with metadata\n   */\n  async executeWithProvider(provider, request) {\n    if (this.isShuttingDown) {\n      throw new Error('Provider manager is shutting down');\n    }\n\n    try {\n      const startTime = Date.now();\n      const result = await provider.complete(request);\n      const endTime = Date.now();\n      \n      // Add provider metadata\n      const enhancedResult = {\n        ...result,\n        provider: provider.getName(),\n        metadata: {\n          ...result.metadata,\n          totalDuration: endTime - startTime,\n          executionTime: endTime - startTime,\n          executionTimestamp: endTime,\n          provider: provider.getName()\n        }\n      };\n      \n      // Record success in failover manager\n      this.failoverManager.recordSuccess(\n        provider.getName(),\n        endTime - startTime,\n        result.cost?.total || 0\n      );\n      \n      return enhancedResult;\n      \n    } catch (error) {\n      // Enhance error with provider context\n      error.provider = provider.getName();\n      error.duration = Date.now();\n      error.message = `Provider error: ${error.message}`;\n      \n      // Record failure in failover manager\n      this.failoverManager.recordFailure(provider.getName(), error);\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Handle provider failure and update health tracking\n   * @param {string} providerName - Name of the failed provider\n   * @param {Error} error - The error that occurred\n   */\n  handleProviderFailure(providerName, error) {\n    const health = this.providerHealth[providerName];\n    if (!health) {\n      logger.warn('Attempted to handle failure for unknown provider', { providerName });\n      return;\n    }\n    \n    health.consecutiveFailures++;\n    health.lastFailure = new Date();\n    \n    // Mark provider as unavailable if too many failures\n    if (health.consecutiveFailures >= this.config.maxConsecutiveFailures) {\n      health.isAvailable = false;\n      logger.warn('Provider marked as unavailable due to consecutive failures', {\n        provider: providerName,\n        consecutiveFailures: health.consecutiveFailures\n      });\n    }\n    \n    // Also record in failover manager\n    this.failoverManager.recordFailure(providerName, error);\n    \n    logger.debug('Provider failure recorded', {\n      provider: providerName,\n      consecutiveFailures: health.consecutiveFailures,\n      isAvailable: health.isAvailable,\n      error: error.message\n    });\n  }\n\n  /**\n   * Get the best available provider for a given task\n   * @param {string} taskType - Type of task (e.g., 'summarization', 'extraction')\n   * @param {number} documentSize - Size of document in characters\n   * @param {Array<string>} excludeProviders - Providers to exclude from selection\n   * @returns {Object} Selected provider\n   */\n  async getProvider(taskType = 'general', documentSize = 0, excludeProviders = []) {\n    const availableProviders = this.getAvailableProviders(excludeProviders);\n    \n    if (availableProviders.length === 0) {\n      throw new Error('No available providers for task execution');\n    }\n\n    // Provider selection strategy based on task type and document size\n    const selectedProvider = this.selectProviderByStrategy(\n      availableProviders,\n      taskType,\n      documentSize\n    );\n\n    logger.info('Provider selected for task', {\n      provider: selectedProvider.getName(),\n      taskType,\n      documentSize,\n      availableProviders: availableProviders.map(p => p.getName())\n    });\n\n    return selectedProvider;\n  }\n\n  /**\n   * Get list of available (healthy) providers\n   * @param {Array<string>} excludeProviders - Providers to exclude\n   * @returns {Array<Object>} Available provider instances\n   */\n  getAvailableProviders(excludeProviders = []) {\n    return Array.from(this.providers.values())\n      .filter(provider => {\n        if (excludeProviders.includes(provider.getName())) return false;\n        \n        const health = this.providerHealth[provider.getName()];\n        return health?.isAvailable && provider.isHealthy;\n      });\n  }\n\n  /**\n   * Select provider based on task requirements\n   * @param {Array<Object>} providers - Available providers\n   * @param {string} taskType - Task type\n   * @param {number} documentSize - Document size\n   * @returns {Object} Selected provider\n   */\n  selectProviderByStrategy(providers, taskType, documentSize) {\n    // Strategy 1: For large documents, prefer providers with higher token limits\n    if (documentSize > 50000) {\n      const preferredOrder = ['anthropic', 'openai'];\n      for (const providerName of preferredOrder) {\n        const provider = providers.find(p => p.getName() === providerName);\n        if (provider) return provider;\n      }\n    }\n\n    // Strategy 2: For cost-sensitive tasks, prefer cheaper providers\n    if (taskType === 'bulk_processing') {\n      const preferredOrder = ['anthropic', 'openai']; // Anthropic Haiku is cheaper\n      for (const providerName of preferredOrder) {\n        const provider = providers.find(p => p.getName() === providerName);\n        if (provider) return provider;\n      }\n    }\n\n    // Strategy 3: For high-quality tasks, prefer premium models\n    if (taskType === 'critical_analysis') {\n      const preferredOrder = ['openai', 'anthropic']; // GPT-4 for critical tasks\n      for (const providerName of preferredOrder) {\n        const provider = providers.find(p => p.getName() === providerName);\n        if (provider) return provider;\n      }\n    }\n\n    // Default: Return provider with lowest error rate\n    return providers.reduce((best, current) => {\n      const bestHealth = this.providerHealth[best.getName()];\n      const currentHealth = this.providerHealth[current.getName()];\n      \n      return currentHealth.consecutiveFailures < bestHealth.consecutiveFailures \n        ? current \n        : best;\n    });\n  }\n\n  /**\n   * Start periodic health monitoring\n   */\n  startHealthMonitoring() {\n    // Skip health monitoring if interval is 0 (for testing)\n    if (this.config.healthCheckInterval === 0) {\n      logger.info('Health monitoring disabled (interval = 0)');\n      return;\n    }\n    \n    this.healthCheckInterval = setInterval(async () => {\n      await this.performHealthChecks();\n    }, this.config.healthCheckInterval);\n\n    logger.info('Health monitoring started', {\n      interval: this.config.healthCheckInterval\n    });\n  }\n\n  /**\n   * Perform health checks on all providers\n   */\n  async performHealthChecks() {\n    const healthPromises = Array.from(this.providers.entries()).map(async ([name, provider]) => {\n      try {\n        const health = await provider.healthCheck();\n        \n        if (health.healthy) {\n          // Reset availability if provider is healthy again\n          this.providerHealth[name].isAvailable = true;\n          this.providerHealth[name].consecutiveFailures = 0;\n        }\n\n        return { name, health };\n      } catch (error) {\n        logger.error('Health check failed', { provider: name, error: error.message });\n        return { name, health: { healthy: false, error: error.message } };\n      }\n    });\n\n    const results = await Promise.allSettled(healthPromises);\n    \n    logger.debug('Health check completed', {\n      results: results.map(r => r.status === 'fulfilled' ? r.value : { error: r.reason })\n    });\n  }\n\n  /**\n   * Get system health and statistics\n   * @returns {Object} Health and stats summary\n   */\n  getSystemHealth() {\n    const providerStats = Array.from(this.providers.entries()).map(([name, provider]) => ({\n      name,\n      ...provider.getStats(),\n      health: this.providerHealth[name]\n    }));\n    \n    const totalRequests = providerStats.reduce((sum, p) => sum + p.requestCount, 0);\n    const totalErrors = providerStats.reduce((sum, p) => sum + p.errorCount, 0);\n    const availableProviders = providerStats.filter(p => p.health.isAvailable).length;\n\n    // Get enhanced failover statistics\n    const failoverStats = this.failoverManager.getFailoverStats();\n\n    return {\n      totalProviders: this.providers.size,\n      availableProviders,\n      totalRequests,\n      totalErrors,\n      errorRate: totalRequests > 0 ? (totalErrors / totalRequests) : 0,\n      providers: providerStats,\n      failover: failoverStats\n    };\n  }\n\n  /**\n   * Initialize prompt version manager\n   */\n  async initializePromptVersioning() {\n    try {\n      await this.promptVersionManager.initialize();\n      logger.info('Prompt versioning system initialized');\n    } catch (error) {\n      logger.error('Failed to initialize prompt versioning', { error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute enrichment with versioned prompt\n   * @param {string} promptId - ID of the prompt to use\n   * @param {Object} variables - Variables to substitute in the prompt\n   * @param {Object} options - Execution options\n   * @returns {Promise<Object>} Enrichment result with prompt metadata\n   */\n  async executeWithPrompt(promptId, variables = {}, options = {}) {\n    try {\n      const {\n        promptVersion = 'latest',\n        provider = null,\n        taskType = 'enrichment',\n        ...executeOptions\n      } = options;\n\n      // Get the versioned prompt\n      const prompt = await this.promptVersionManager.getPrompt(promptId, promptVersion);\n      if (!prompt) {\n        throw new Error(`Prompt not found: ${promptId} (version: ${promptVersion})`);\n      }\n\n      // Substitute variables in prompt content\n      const processedContent = this.substitutePromptVariables(prompt.content, variables);\n\n      // Execute with failover\n      const result = await this.executeWithFailover({\n        taskType,\n        prompt: processedContent,\n        ...executeOptions\n      });\n\n      // Add prompt metadata to result\n      return {\n        ...result,\n        promptMetadata: {\n          promptId,\n          promptVersion: prompt.version,\n          variables,\n          promptHash: this.generatePromptHash(prompt),\n          executionTimestamp: new Date().toISOString()\n        }\n      };\n    } catch (error) {\n      logger.error('Failed to execute with prompt', {\n        promptId,\n        promptVersion: options.promptVersion,\n        error: error.message\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Substitute variables in prompt content\n   * @param {string} content - Prompt content with variables\n   * @param {Object} variables - Variables to substitute\n   * @returns {string} Processed content\n   */\n  substitutePromptVariables(content, variables) {\n    let processedContent = content;\n    \n    for (const [key, value] of Object.entries(variables)) {\n      const regex = new RegExp(`\\\\{\\\\{${key}\\\\}\\\\}`, 'g');\n      processedContent = processedContent.replace(regex, String(value));\n    }\n\n    // Check for unsubstituted variables\n    const unsubstituted = processedContent.match(/\\{\\{\\w+\\}\\}/g);\n    if (unsubstituted) {\n      logger.warn('Unsubstituted variables found in prompt', { \n        variables: unsubstituted,\n        promptContent: processedContent.substring(0, 100) + '...'\n      });\n    }\n\n    return processedContent;\n  }\n\n  /**\n   * Generate hash for prompt reproducibility\n   * @param {Object} prompt - Prompt object\n   * @returns {string} Hash string\n   */\n  generatePromptHash(prompt) {\n    const crypto = require('crypto');\n    const hashData = {\n      id: prompt.id,\n      version: prompt.version,\n      content: prompt.content\n    };\n    return crypto.createHash('sha256').update(JSON.stringify(hashData)).digest('hex');\n  }\n\n  /**\n   * Save or update a prompt\n   * @param {string} promptId - Prompt identifier\n   * @param {Object} promptData - Prompt content and metadata\n   * @param {Object} options - Save options\n   * @returns {Promise<Object>} Saved prompt\n   */\n  async savePrompt(promptId, promptData, options = {}) {\n    try {\n      return await this.promptVersionManager.savePrompt(promptId, promptData, options);\n    } catch (error) {\n      logger.error('Failed to save prompt', { promptId, error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Get a prompt by ID and version\n   * @param {string} promptId - Prompt identifier\n   * @param {string} version - Prompt version (default: 'latest')\n   * @returns {Promise<Object|null>} Prompt object or null\n   */\n  async getPrompt(promptId, version = 'latest') {\n    try {\n      return await this.promptVersionManager.getPrompt(promptId, version);\n    } catch (error) {\n      logger.error('Failed to get prompt', { promptId, version, error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * List all available prompts\n   * @returns {Array<string>} Array of prompt IDs\n   */\n  listPrompts() {\n    return this.promptVersionManager.listPrompts();\n  }\n\n  /**\n   * Get version history for a prompt\n   * @param {string} promptId - Prompt identifier\n   * @returns {Array<Object>} Version history\n   */\n  getPromptVersionHistory(promptId) {\n    return this.promptVersionManager.getVersionHistory(promptId);\n  }\n\n  /**\n   * Rollback prompt to a previous version\n   * @param {string} promptId - Prompt identifier\n   * @param {string} targetVersion - Target version to rollback to\n   * @returns {Promise<Object>} Rollback result\n   */\n  async rollbackPrompt(promptId, targetVersion) {\n    try {\n      return await this.promptVersionManager.rollbackPrompt(promptId, targetVersion);\n    } catch (error) {\n      logger.error('Failed to rollback prompt', { promptId, targetVersion, error: error.message });\n      throw error;\n    }\n  }\n\n  /**\n   * Get prompt versioning statistics\n   * @returns {Object} Statistics\n   */\n  getPromptStatistics() {\n    return this.promptVersionManager.getStatistics();\n  }\n\n  /**\n   * Gracefully shutdown the provider manager\n   */\n  async shutdown() {\n    this.isShuttingDown = true;\n    \n    logger.info('Shutting down LLM Provider Manager');\n    \n    // Stop health monitoring\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n      this.healthCheckInterval = null;\n    }\n    \n    // Shutdown failover manager\n    await this.failoverManager.shutdown();\n    \n    // Shutdown prompt version manager\n    await this.promptVersionManager.shutdown();\n    \n    // Shutdown all providers\n    const shutdownPromises = Array.from(this.providers.values()).map(async (provider) => {\n      try {\n        if (typeof provider.shutdown === 'function') {\n          await provider.shutdown();\n        }\n      } catch (error) {\n        logger.error('Error shutting down provider', {\n          provider: provider.getName(),\n          error: error.message\n        });\n      }\n    });\n    \n    await Promise.all(shutdownPromises);\n    \n    logger.info('LLM Provider Manager shutdown complete');\n  }\n}\n\nmodule.exports = LLMProviderManager;\n"],"mappings":"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","ignoreList":[]}