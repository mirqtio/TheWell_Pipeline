/**
 * Integration Tests for Prompt Versioning System
 * Tests the complete prompt template management workflow with real git operations
 */

const path = require('path');
const fs = require('fs');
const PromptTemplateManager = require('../../../src/enrichment/PromptTemplateManager');
const LLMProviderManager = require('../../../src/enrichment/LLMProviderManager');

describe('Prompt Versioning Integration', () => {
  let promptManager;
  let providerManager;
  const testRepoPath = path.join(__dirname, '../../../temp/integration-prompts');

  beforeAll(async () => {
    // Clean up test repository
    if (fs.existsSync(testRepoPath)) {
      fs.rmSync(testRepoPath, { recursive: true, force: true });
    }

    promptManager = new PromptTemplateManager({
      repoPath: testRepoPath,
      autoInit: true
    });

    providerManager = new LLMProviderManager({
      openai: {
        apiKey: 'test-key-disabled'
      },
      healthCheckInterval: 0 // Disable health monitoring for tests
    });
    
    await promptManager.initialize();
  });

  afterAll(async () => {
    if (promptManager) {
      await promptManager.cleanup();
    }
    if (providerManager) {
      await providerManager.shutdown();
    }
  });

  describe('end-to-end prompt workflow', () => {
    test('should manage complete prompt lifecycle', async () => {
      // 1. Create initial template
      const template = {
        name: 'document-analysis',
        template: `Analyze the following document and provide:
1. Main topics: {{document}}
2. Sentiment: positive/negative/neutral
3. Key entities mentioned

Document: {{content}}`,
        variables: ['document', 'content'],
        metadata: {
          author: 'integration-test',
          category: 'analysis',
          description: 'Document analysis prompt for testing'
        }
      };

      const v1 = await promptManager.storeTemplate(template);
      expect(v1.version).toBe('1.0.0');

      // 2. Verify template retrieval
      const retrieved = await promptManager.getTemplate('document-analysis');
      expect(retrieved.template).toContain('Main topics');
      expect(retrieved.variables).toEqual(['document', 'content']);

      // 3. Update template with improvements
      template.template = `Enhanced analysis of the document:
1. Primary topics: {{document}}
2. Sentiment analysis: positive/negative/neutral  
3. Named entities: people, places, organizations
4. Summary in 2-3 sentences

Document content: {{content}}`;

      const v2 = await promptManager.storeTemplate(template);
      expect(v2.version).toBe('1.0.1');

      // 4. Test version history
      const versions = await promptManager.getTemplateVersions('document-analysis');
      expect(versions).toHaveLength(2);
      expect(versions[0].version).toBe('1.0.1'); // Latest first

      // 5. Test rollback functionality
      const rollback = await promptManager.rollbackToVersion('document-analysis', '1.0.0');
      expect(rollback.success).toBe(true);

      const afterRollback = await promptManager.getTemplate('document-analysis');
      expect(afterRollback.template).toContain('Main topics');
      expect(afterRollback.template).not.toContain('Enhanced analysis');
    });

    test('should integrate with LLM provider system', async () => {
      // Create prompt template
      const template = {
        name: 'llm-integration-test',
        template: 'Summarize this text in {{word_count}} words: {{text}}',
        variables: ['word_count', 'text'],
        metadata: {
          provider: 'openai',
          model: 'gpt-3.5-turbo',
          maxTokens: 150
        }
      };

      const stored = await promptManager.storeTemplate(template);
      expect(stored.success).toBe(true);

      // Link template to hypothetical LLM output
      const outputMetadata = {
        documentId: 'integration-doc-123',
        enrichmentType: 'summarization',
        provider: 'openai',
        model: 'gpt-3.5-turbo',
        timestamp: new Date().toISOString(),
        inputTokens: 500,
        outputTokens: 100,
        cost: 0.002,
        result: 'This is a test summary generated by the LLM provider.'
      };

      const linkResult = await promptManager.linkToOutput(
        stored.templateId,
        stored.version,
        outputMetadata
      );

      expect(linkResult.success).toBe(true);

      // Verify linked outputs can be retrieved
      const linkedOutputs = await promptManager.getLinkedOutputs(
        stored.templateId,
        stored.version
      );

      expect(linkedOutputs).toHaveLength(1);
      expect(linkedOutputs[0].documentId).toBe('integration-doc-123');
      expect(linkedOutputs[0].provider).toBe('openai');
      expect(linkedOutputs[0].cost).toBe(0.002);
    });
  });

  describe('concurrent template operations', () => {
    test('should handle concurrent template updates safely', async () => {
      const baseName = 'concurrent-test';
      
      // Create base template
      await promptManager.storeTemplate({
        name: baseName,
        template: 'Base template: {{input}}',
        variables: ['input']
      });

      // Simulate sequential updates (to avoid git lock conflicts)
      const results = [];
      for (let i = 1; i <= 3; i++) {
        const result = await promptManager.storeTemplate({
          name: baseName,
          template: `Sequential update ${i}: {{input}}`,
          variables: ['input']
        });
        results.push(result);
        // Small delay to avoid git conflicts
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      // All updates should succeed with different versions
      results.forEach(result => {
        expect(result.success).toBe(true);
        expect(result.version).toBeDefined();
      });

      // Verify all versions are tracked
      const versions = await promptManager.getTemplateVersions(baseName);
      expect(versions.length).toBeGreaterThanOrEqual(3);
    });
  });

  describe('template search and filtering', () => {
    beforeEach(async () => {
      // Setup test templates with different categories
      const templates = [
        {
          name: 'search-summary',
          template: 'Summarize: {{content}}',
          variables: ['content'],
          metadata: { category: 'summarization', tags: ['nlp', 'text'] }
        },
        {
          name: 'search-analysis',
          template: 'Analyze: {{data}}',
          variables: ['data'], 
          metadata: { category: 'analysis', tags: ['data', 'insights'] }
        },
        {
          name: 'search-extraction',
          template: 'Extract entities from: {{text}}',
          variables: ['text'],
          metadata: { category: 'extraction', tags: ['nlp', 'entities'] }
        }
      ];

      for (const template of templates) {
        await promptManager.storeTemplate(template);
      }
    });

    test('should search templates by category', async () => {
      const summaryTemplates = await promptManager.searchTemplates({
        category: 'summarization'
      });

      expect(summaryTemplates).toHaveLength(1);
      expect(summaryTemplates[0].name).toBe('search-summary');
    });

    test('should search templates by tags', async () => {
      const nlpTemplates = await promptManager.searchTemplates({
        tags: ['nlp']
      });

      expect(nlpTemplates).toHaveLength(2);
      expect(nlpTemplates.map(t => t.name)).toContain('search-summary');
      expect(nlpTemplates.map(t => t.name)).toContain('search-extraction');
    });

    test('should search templates by text content', async () => {
      const analyzeTemplates = await promptManager.searchTemplates({
        text: 'Analyze'
      });

      expect(analyzeTemplates.length).toBeGreaterThanOrEqual(1);
      const searchAnalysisTemplate = analyzeTemplates.find(t => t.name === 'search-analysis');
      expect(searchAnalysisTemplate).toBeDefined();
    });
  });

  describe('backup and recovery', () => {
    test('should backup and restore template repository', async () => {
      // Create test templates
      await promptManager.storeTemplate({
        name: 'backup-test-1',
        template: 'First template: {{input}}',
        variables: ['input']
      });

      await promptManager.storeTemplate({
        name: 'backup-test-2', 
        template: 'Second template: {{data}}',
        variables: ['data']
      });

      // Create backup
      const backupPath = path.join(__dirname, '../../../temp/prompt-backup');
      const backupResult = await promptManager.createBackup(backupPath);
      expect(backupResult.success).toBe(true);
      expect(fs.existsSync(backupPath)).toBe(true);

      // Simulate data loss (remove templates)
      await promptManager.cleanup();
      fs.rmSync(testRepoPath, { recursive: true, force: true });

      // Restore from backup
      promptManager = new PromptTemplateManager({
        repoPath: testRepoPath,
        autoInit: false
      });

      const restoreResult = await promptManager.restoreFromBackup(backupPath);
      expect(restoreResult.success).toBe(true);

      // Verify templates are restored
      const template1 = await promptManager.getTemplate('backup-test-1');
      const template2 = await promptManager.getTemplate('backup-test-2');

      expect(template1.template).toBe('First template: {{input}}');
      expect(template2.template).toBe('Second template: {{data}}');

      // Cleanup backup
      fs.rmSync(backupPath, { recursive: true, force: true });
    });
  });
});